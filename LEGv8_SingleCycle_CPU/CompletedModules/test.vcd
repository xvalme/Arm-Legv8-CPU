$date
	Sat Feb 26 17:10:23 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module CPU_tb $end
$scope module cpu $end
$var wire 1 ! clock $end
$var wire 1 " en_jump $end
$var wire 1 # writemem_en $end
$var wire 64 $ write_data [63:0] $end
$var wire 64 % sign_extended_address [63:0] $end
$var wire 1 & reg2loc $end
$var wire 1 ' readmem_en $end
$var wire 64 ( read2 [63:0] $end
$var wire 64 ) read1 [63:0] $end
$var wire 5 * out_reg2loc [4:0] $end
$var wire 64 + out_ALUSrc [63:0] $end
$var wire 1 , memtoreg $end
$var wire 64 - mem_data [63:0] $end
$var wire 64 . jump_address [63:0] $end
$var wire 32 / instruction [31:0] $end
$var wire 64 0 counter [63:0] $end
$var wire 1 1 Zero $end
$var wire 1 2 UncBranch $end
$var wire 1 3 RegWrite $end
$var wire 1 4 Branch $end
$var wire 2 5 AluOp [1:0] $end
$var wire 64 6 ALU_out [63:0] $end
$var wire 1 7 ALUSrc $end
$var wire 4 8 ALUCtrl [3:0] $end
$scope module ALU $end
$var wire 64 9 B [63:0] $end
$var wire 4 : ALUctr [3:0] $end
$var wire 64 ; A [63:0] $end
$var reg 64 < Out [63:0] $end
$var reg 1 1 Zero $end
$upscope $end
$scope module JumpAdder $end
$var wire 4 = ALUctr [3:0] $end
$var wire 64 > B [63:0] $end
$var wire 64 ? A [63:0] $end
$var reg 64 @ Out [63:0] $end
$var reg 1 A Zero $end
$upscope $end
$scope module PC $end
$var wire 1 ! clock $end
$var wire 1 " en_jump $end
$var wire 64 B jump [63:0] $end
$var reg 64 C counter [63:0] $end
$upscope $end
$scope module ROM $end
$var wire 1 ! clock $end
$var wire 64 D counter [63:0] $end
$var reg 32 E instruction [31:0] $end
$upscope $end
$scope module aluctrl $end
$var wire 11 F ALU_INSTRUCTION [10:0] $end
$var wire 2 G ALU_Op [1:0] $end
$var reg 4 H ALU_Out [3:0] $end
$upscope $end
$scope module alusrc_mux $end
$var wire 64 I reg2 [63:0] $end
$var wire 1 7 alusrc $end
$var wire 64 J address [63:0] $end
$var reg 64 K out [63:0] $end
$upscope $end
$scope module control_unit $end
$var wire 11 L Instruction [10:0] $end
$var reg 1 7 ALUSrc $end
$var reg 2 M AluOp [1:0] $end
$var reg 1 4 Branch $end
$var reg 1 ' MemRead $end
$var reg 1 # MemWrite $end
$var reg 1 , MemtoReg $end
$var reg 1 & Reg2Loc $end
$var reg 1 3 RegWrite $end
$var reg 1 2 UncBranch $end
$upscope $end
$scope module memtoreg_mux $end
$var wire 64 N ALU_result [63:0] $end
$var wire 1 , src $end
$var wire 64 O data [63:0] $end
$var reg 64 P out [63:0] $end
$upscope $end
$scope module ram $end
$var wire 64 Q address [63:0] $end
$var wire 1 ' read_en $end
$var wire 1 # write_en $end
$var wire 64 R data_in [63:0] $end
$var reg 64 S out [63:0] $end
$var integer 32 T initCount [31:0] $end
$upscope $end
$scope module reg2loc_mux $end
$var wire 5 U a [4:0] $end
$var wire 5 V b [4:0] $end
$var wire 1 & in_cable $end
$var reg 5 W out [4:0] $end
$upscope $end
$scope module regs $end
$var wire 5 X add1 [4:0] $end
$var wire 5 Y add2 [4:0] $end
$var wire 1 ! clock $end
$var wire 5 Z write_add [4:0] $end
$var wire 64 [ write_data [63:0] $end
$var wire 1 3 write_en $end
$var reg 64 \ read_1 [63:0] $end
$var reg 64 ] read_2 [63:0] $end
$var integer 32 ^ i [31:0] $end
$upscope $end
$scope module sign_extender $end
$var wire 32 _ in [31:0] $end
$var reg 64 ` out [63:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b110000 `
b10001010000000110000000001000010 _
b11111 ^
bx ]
bx \
bx [
b10 Z
b11 Y
b10 X
b11 W
b10 V
b11 U
b100000 T
bx S
bx R
bx Q
bx P
bx O
bx N
b10 M
b10001010000 L
bx K
b110000 J
bx I
b0 H
b10 G
b10001010000 F
b10001010000000110000000001000010 E
b1 D
b1 C
b110001 B
0A
b110001 @
b1 ?
b110000 >
b10 =
bx <
bx ;
b0 :
bx 9
b0 8
07
bx 6
b10 5
04
13
02
01
b1 0
b10001010000000110000000001000010 /
b110001 .
bx -
0,
bx +
b11 *
bx )
bx (
0'
0&
b110000 %
bx $
0#
0"
0!
$end
#1
b10 $
b10 P
b10 [
b11 +
b11 9
b11 K
b10 6
b10 <
b10 N
b10 Q
b11 (
b11 I
b11 R
b11 ]
b10 )
b10 ;
b10 \
1!
#2
1A
b1 $
b1 P
b1 [
b1 6
b1 <
b1 N
b1 Q
b111 8
b111 :
b111 H
1"
b1 5
b1 G
b1 M
12
03
b11111 *
b11111 W
b11111 Y
b1111111111111111111111111111111111111111111111111111111111111110 %
b1111111111111111111111111111111111111111111111111111111111111110 >
b1111111111111111111111111111111111111111111111111111111111111110 J
b1111111111111111111111111111111111111111111111111111111111111110 `
b0 .
b0 @
b0 B
b10111111 L
b10111111 F
b11110 Z
b11111 X
b11110 V
b11111 U
b10111111111111111111111111110 /
b10111111111111111111111111110 E
b10111111111111111111111111110 _
b10 0
b10 ?
b10 C
b10 D
0!
#3
11
b0 $
b0 P
b0 [
b0 6
b0 <
b0 N
b0 Q
b0 +
b0 9
b0 K
b0 (
b0 I
b0 R
b0 ]
b0 )
b0 ;
b0 \
1!
#4
01
bx 6
bx <
bx N
bx Q
bx -
bx O
bx S
bx $
bx P
bx [
0A
b0xxxxxxxxx +
b0xxxxxxxxx 9
b0xxxxxxxxx K
b10 8
b10 :
b10 H
0"
b0 5
b0 G
b0 M
02
1'
13
1,
17
bx *
bx W
bx Y
bx .
bx @
bx B
b0xxxxxxxxx %
b0xxxxxxxxx >
b0xxxxxxxxx J
b0xxxxxxxxx `
bx L
bx F
bx Z
bx X
bx V
bx U
b1 0
b1 ?
b1 C
b1 D
bx /
bx E
bx _
0!
#5
bx (
bx I
bx R
bx ]
bx )
bx ;
bx \
1!
#6
1A
b0x $
b0x P
b0x [
b0x 6
b0x <
b0x N
b0x Q
b0 .
b0 @
b0 B
bx +
bx 9
bx K
b111 8
b111 :
b111 H
1"
b1 5
b1 G
b1 M
12
0'
03
0,
07
b11111 *
b11111 W
b11111 Y
b1111111111111111111111111111111111111111111111111111111111111110 %
b1111111111111111111111111111111111111111111111111111111111111110 >
b1111111111111111111111111111111111111111111111111111111111111110 J
b1111111111111111111111111111111111111111111111111111111111111110 `
b10111111 L
b10111111 F
b11110 Z
b11111 X
b11110 V
b11111 U
b10111111111111111111111111110 /
b10111111111111111111111111110 E
b10111111111111111111111111110 _
b10 0
b10 ?
b10 C
b10 D
0!
#7
11
b0 $
b0 P
b0 [
b0 6
b0 <
b0 N
b0 Q
b0 +
b0 9
b0 K
b0 (
b0 I
b0 R
b0 ]
b0 )
b0 ;
b0 \
1!
#8
01
bx 6
bx <
bx N
bx Q
bx -
bx O
bx S
bx $
bx P
bx [
0A
b0xxxxxxxxx +
b0xxxxxxxxx 9
b0xxxxxxxxx K
b10 8
b10 :
b10 H
0"
b0 5
b0 G
b0 M
02
1'
13
1,
17
bx *
bx W
bx Y
bx .
bx @
bx B
b0xxxxxxxxx %
b0xxxxxxxxx >
b0xxxxxxxxx J
b0xxxxxxxxx `
bx L
bx F
bx Z
bx X
bx V
bx U
b1 0
b1 ?
b1 C
b1 D
bx /
bx E
bx _
0!
#9
bx (
bx I
bx R
bx ]
bx )
bx ;
bx \
1!
#10
1A
b0x $
b0x P
b0x [
b0x 6
b0x <
b0x N
b0x Q
b0 .
b0 @
b0 B
bx +
bx 9
bx K
b111 8
b111 :
b111 H
1"
b1 5
b1 G
b1 M
12
0'
03
0,
07
b11111 *
b11111 W
b11111 Y
b1111111111111111111111111111111111111111111111111111111111111110 %
b1111111111111111111111111111111111111111111111111111111111111110 >
b1111111111111111111111111111111111111111111111111111111111111110 J
b1111111111111111111111111111111111111111111111111111111111111110 `
b10111111 L
b10111111 F
b11110 Z
b11111 X
b11110 V
b11111 U
b10111111111111111111111111110 /
b10111111111111111111111111110 E
b10111111111111111111111111110 _
b10 0
b10 ?
b10 C
b10 D
0!
#11
11
b0 $
b0 P
b0 [
b0 6
b0 <
b0 N
b0 Q
b0 +
b0 9
b0 K
b0 (
b0 I
b0 R
b0 ]
b0 )
b0 ;
b0 \
1!
#12
01
bx 6
bx <
bx N
bx Q
bx -
bx O
bx S
bx $
bx P
bx [
0A
b0xxxxxxxxx +
b0xxxxxxxxx 9
b0xxxxxxxxx K
b10 8
b10 :
b10 H
0"
b0 5
b0 G
b0 M
02
1'
13
1,
17
bx *
bx W
bx Y
bx .
bx @
bx B
b0xxxxxxxxx %
b0xxxxxxxxx >
b0xxxxxxxxx J
b0xxxxxxxxx `
bx L
bx F
bx Z
bx X
bx V
bx U
b1 0
b1 ?
b1 C
b1 D
bx /
bx E
bx _
0!
#13
bx (
bx I
bx R
bx ]
bx )
bx ;
bx \
1!
#14
1A
b0x $
b0x P
b0x [
b0x 6
b0x <
b0x N
b0x Q
b0 .
b0 @
b0 B
bx +
bx 9
bx K
b111 8
b111 :
b111 H
1"
b1 5
b1 G
b1 M
12
0'
03
0,
07
b11111 *
b11111 W
b11111 Y
b1111111111111111111111111111111111111111111111111111111111111110 %
b1111111111111111111111111111111111111111111111111111111111111110 >
b1111111111111111111111111111111111111111111111111111111111111110 J
b1111111111111111111111111111111111111111111111111111111111111110 `
b10111111 L
b10111111 F
b11110 Z
b11111 X
b11110 V
b11111 U
b10111111111111111111111111110 /
b10111111111111111111111111110 E
b10111111111111111111111111110 _
b10 0
b10 ?
b10 C
b10 D
0!
#15
11
b0 $
b0 P
b0 [
b0 6
b0 <
b0 N
b0 Q
b0 +
b0 9
b0 K
b0 (
b0 I
b0 R
b0 ]
b0 )
b0 ;
b0 \
1!
#16
01
bx 6
bx <
bx N
bx Q
bx -
bx O
bx S
bx $
bx P
bx [
0A
b0xxxxxxxxx +
b0xxxxxxxxx 9
b0xxxxxxxxx K
b10 8
b10 :
b10 H
0"
b0 5
b0 G
b0 M
02
1'
13
1,
17
bx *
bx W
bx Y
bx .
bx @
bx B
b0xxxxxxxxx %
b0xxxxxxxxx >
b0xxxxxxxxx J
b0xxxxxxxxx `
bx L
bx F
bx Z
bx X
bx V
bx U
b1 0
b1 ?
b1 C
b1 D
bx /
bx E
bx _
0!
#17
bx (
bx I
bx R
bx ]
bx )
bx ;
bx \
1!
#18
1A
b0x $
b0x P
b0x [
b0x 6
b0x <
b0x N
b0x Q
b0 .
b0 @
b0 B
bx +
bx 9
bx K
b111 8
b111 :
b111 H
1"
b1 5
b1 G
b1 M
12
0'
03
0,
07
b11111 *
b11111 W
b11111 Y
b1111111111111111111111111111111111111111111111111111111111111110 %
b1111111111111111111111111111111111111111111111111111111111111110 >
b1111111111111111111111111111111111111111111111111111111111111110 J
b1111111111111111111111111111111111111111111111111111111111111110 `
b10111111 L
b10111111 F
b11110 Z
b11111 X
b11110 V
b11111 U
b10111111111111111111111111110 /
b10111111111111111111111111110 E
b10111111111111111111111111110 _
b10 0
b10 ?
b10 C
b10 D
0!
#19
11
b0 $
b0 P
b0 [
b0 6
b0 <
b0 N
b0 Q
b0 +
b0 9
b0 K
b0 (
b0 I
b0 R
b0 ]
b0 )
b0 ;
b0 \
1!
#20
01
bx 6
bx <
bx N
bx Q
bx -
bx O
bx S
bx $
bx P
bx [
0A
b0xxxxxxxxx +
b0xxxxxxxxx 9
b0xxxxxxxxx K
b10 8
b10 :
b10 H
0"
b0 5
b0 G
b0 M
02
1'
13
1,
17
bx *
bx W
bx Y
bx .
bx @
bx B
b0xxxxxxxxx %
b0xxxxxxxxx >
b0xxxxxxxxx J
b0xxxxxxxxx `
bx L
bx F
bx Z
bx X
bx V
bx U
b1 0
b1 ?
b1 C
b1 D
bx /
bx E
bx _
0!
