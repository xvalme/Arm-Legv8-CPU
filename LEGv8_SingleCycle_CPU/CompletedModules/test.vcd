$date
	Fri Feb 25 18:16:22 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module CPU_tb $end
$scope module cpu $end
$var wire 1 ! clock $end
$var wire 1 " en_jump $end
$var wire 1 # writemem_en $end
$var wire 64 $ write_data [63:0] $end
$var wire 64 % sign_extended_address [63:0] $end
$var wire 1 & reg2loc $end
$var wire 1 ' readmem_en $end
$var wire 64 ( read2 [63:0] $end
$var wire 64 ) read1 [63:0] $end
$var wire 5 * out_reg2loc [4:0] $end
$var wire 64 + out_ALUSrc [63:0] $end
$var wire 1 , memtoreg $end
$var wire 64 - mem_data [63:0] $end
$var wire 64 . jump_address [63:0] $end
$var wire 32 / instruction [31:0] $end
$var wire 64 0 counter [63:0] $end
$var wire 1 1 Zero $end
$var wire 1 2 RegWrite $end
$var wire 1 3 Branch $end
$var wire 2 4 AluOp [1:0] $end
$var wire 64 5 ALU_out [63:0] $end
$var wire 1 6 ALUSrc $end
$var wire 4 7 ALUCtrl [3:0] $end
$scope module ALU $end
$var wire 64 8 B [63:0] $end
$var wire 4 9 ALUctr [3:0] $end
$var wire 64 : A [63:0] $end
$var reg 64 ; Out [63:0] $end
$var reg 1 1 Zero $end
$upscope $end
$scope module JumpAdder $end
$var wire 4 < ALUctr [3:0] $end
$var wire 64 = B [63:0] $end
$var wire 64 > A [63:0] $end
$var reg 64 ? Out [63:0] $end
$var reg 1 @ Zero $end
$upscope $end
$scope module PC $end
$var wire 1 ! clock $end
$var wire 1 " en_jump $end
$var wire 64 A jump [63:0] $end
$var reg 64 B counter [63:0] $end
$upscope $end
$scope module ROM $end
$var wire 1 ! clock $end
$var wire 64 C counter [63:0] $end
$var reg 32 D instruction [31:0] $end
$upscope $end
$scope module aluctrl $end
$var wire 11 E ALU_INSTRUCTION [10:0] $end
$var wire 2 F ALU_Op [1:0] $end
$var reg 4 G ALU_Out [3:0] $end
$upscope $end
$scope module alusrc_mux $end
$var wire 64 H reg2 [63:0] $end
$var wire 1 6 alusrc $end
$var wire 64 I address [63:0] $end
$var reg 64 J out [63:0] $end
$upscope $end
$scope module control_unit $end
$var wire 11 K Instruction [10:0] $end
$var reg 1 6 ALUSrc $end
$var reg 2 L AluOp [1:0] $end
$var reg 1 3 Branch $end
$var reg 1 ' MemRead $end
$var reg 1 # MemWrite $end
$var reg 1 , MemtoReg $end
$var reg 1 & Reg2Loc $end
$var reg 1 2 RegWrite $end
$upscope $end
$scope module memtoreg_mux $end
$var wire 64 M ALU_result [63:0] $end
$var wire 1 , src $end
$var wire 64 N data [63:0] $end
$var reg 64 O out [63:0] $end
$upscope $end
$scope module ram $end
$var wire 64 P address [63:0] $end
$var wire 1 ' read_en $end
$var wire 1 # write_en $end
$var wire 64 Q data_in [63:0] $end
$var reg 64 R out [63:0] $end
$var integer 32 S initCount [31:0] $end
$var integer 32 T u [31:0] $end
$upscope $end
$scope module reg2loc_mux $end
$var wire 5 U a [4:0] $end
$var wire 5 V b [4:0] $end
$var wire 1 & in_cable $end
$var reg 5 W out [4:0] $end
$upscope $end
$scope module regs $end
$var wire 5 X add1 [4:0] $end
$var wire 5 Y add2 [4:0] $end
$var wire 1 ! clock $end
$var wire 5 Z write_add [4:0] $end
$var wire 64 [ write_data [63:0] $end
$var wire 1 2 write_en $end
$var reg 64 \ read_1 [63:0] $end
$var reg 64 ] read_2 [63:0] $end
$var integer 32 ^ i [31:0] $end
$var integer 32 _ u [31:0] $end
$upscope $end
$scope module sign_extender $end
$var wire 32 ` in [31:0] $end
$var reg 64 a out [63:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 a
b1111 `
b100000 _
b11111 ^
bx ]
bx \
bx [
b1111 Z
b0 Y
b0 X
b0 W
b1111 V
b0 U
b100000 T
b100000 S
bx R
bx Q
bx P
bx O
bx N
bx M
b0 L
b0 K
bx J
b0 I
bx H
b10 G
b0 F
b0 E
b1111 D
b1 C
b1 B
b1 A
0@
b1 ?
b1 >
b0 =
b10 <
bx ;
bx :
b10 9
bx 8
b10 7
06
bx 5
b0 4
03
02
01
b1 0
b1111 /
b1 .
bx -
0,
bx +
b0 *
bx )
bx (
0'
0&
b0 %
bx $
0#
0"
0!
$end
#1
11
b0 $
b0 O
b0 [
b0 5
b0 ;
b0 M
b0 P
b0 +
b0 8
b0 J
b100000 T
b0 (
b0 H
b0 Q
b0 ]
b0 )
b0 :
b0 \
1!
#2
b10 .
b10 ?
b10 A
b1000 Z
b1000 V
b1000 /
b1000 D
b1000 `
b10 0
b10 >
b10 B
b10 C
b100000 _
0!
#3
1!
#4
b11 .
b11 ?
b11 A
b100 Z
b100 V
b11 0
b11 >
b11 B
b11 C
b100 /
b100 D
b100 `
b100000 _
0!
#5
1!
#6
b100 .
b100 ?
b100 A
b0 Z
b0 V
b0 /
b0 D
b0 `
b100 0
b100 >
b100 B
b100 C
b100000 _
0!
#7
1!
#8
b101 .
b101 ?
b101 A
b101 0
b101 >
b101 B
b101 C
b100000 _
0!
#9
1!
#10
b110 .
b110 ?
b110 A
b1 Z
b1 V
b1 /
b1 D
b1 `
b110 0
b110 >
b110 B
b110 C
b100000 _
0!
#11
1!
#12
b111 .
b111 ?
b111 A
b100 Z
b100 V
b111 0
b111 >
b111 B
b111 C
b100 /
b100 D
b100 `
b100000 _
0!
#13
1!
#14
b1000 .
b1000 ?
b1000 A
b10 Z
b10 V
b10 /
b10 D
b10 `
b1000 0
b1000 >
b1000 B
b1000 C
b100000 _
0!
#15
1!
#16
01
bx 5
bx ;
bx M
bx P
bx -
bx N
bx R
bx $
bx O
bx [
b0xxxxxxxxx +
b0xxxxxxxxx 8
b0xxxxxxxxx J
b100000 T
1'
12
1,
16
bx *
bx W
bx Y
bx .
bx ?
bx A
b0xxxxxxxxx %
b0xxxxxxxxx =
b0xxxxxxxxx I
b0xxxxxxxxx a
bx K
bx E
bx Z
bx X
bx V
bx U
b1001 0
b1001 >
b1001 B
b1001 C
bx /
bx D
bx `
b100000 _
0!
#17
b100000 T
bx (
bx H
bx Q
bx ]
bx )
bx :
bx \
1!
#18
b1010 0
b1010 >
b1010 B
b1010 C
b100000 _
0!
#19
1!
#20
b1011 0
b1011 >
b1011 B
b1011 C
0!
