$date
	Fri Feb 25 18:03:10 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module CPU_tb $end
$scope module cpu $end
$var wire 1 ! clock $end
$var wire 1 " en_jump $end
$var wire 1 # writemem_en $end
$var wire 64 $ write_data [63:0] $end
$var wire 64 % sign_extended_address [63:0] $end
$var wire 1 & reg2loc $end
$var wire 1 ' readmem_en $end
$var wire 64 ( read2 [63:0] $end
$var wire 64 ) read1 [63:0] $end
$var wire 5 * out_reg2loc [4:0] $end
$var wire 64 + out_ALUSrc [63:0] $end
$var wire 1 , memtoreg $end
$var wire 64 - mem_data [63:0] $end
$var wire 64 . jump_address [63:0] $end
$var wire 32 / instruction [31:0] $end
$var wire 64 0 counter [63:0] $end
$var wire 1 1 Zero $end
$var wire 1 2 RegWrite $end
$var wire 1 3 Branch $end
$var wire 2 4 AluOp [1:0] $end
$var wire 64 5 ALU_out [63:0] $end
$var wire 1 6 ALUSrc $end
$var wire 4 7 ALUCtrl [3:0] $end
$scope module ALU $end
$var wire 64 8 B [63:0] $end
$var wire 4 9 ALUctr [3:0] $end
$var wire 64 : A [63:0] $end
$var reg 64 ; Out [63:0] $end
$var reg 1 1 Zero $end
$upscope $end
$scope module JumpAdder $end
$var wire 4 < ALUctr [3:0] $end
$var wire 64 = B [63:0] $end
$var wire 64 > A [63:0] $end
$var reg 64 ? Out [63:0] $end
$var reg 1 @ Zero $end
$upscope $end
$scope module PC $end
$var wire 1 ! clock $end
$var wire 1 " en_jump $end
$var wire 64 A jump [63:0] $end
$var reg 64 B counter [63:0] $end
$upscope $end
$scope module ROM $end
$var wire 1 ! clock $end
$var wire 64 C counter [63:0] $end
$var reg 32 D instruction [31:0] $end
$upscope $end
$scope module aluctrl $end
$var wire 11 E ALU_INSTRUCTION [10:0] $end
$var wire 2 F ALU_Op [1:0] $end
$var reg 4 G ALU_Out [3:0] $end
$upscope $end
$scope module alusrc_mux $end
$var wire 64 H reg2 [63:0] $end
$var wire 1 6 alusrc $end
$var wire 64 I address [63:0] $end
$var reg 64 J out [63:0] $end
$upscope $end
$scope module control_unit $end
$var wire 11 K Instruction [10:0] $end
$var reg 1 6 ALUSrc $end
$var reg 2 L AluOp [1:0] $end
$var reg 1 3 Branch $end
$var reg 1 ' MemRead $end
$var reg 1 # MemWrite $end
$var reg 1 , MemtoReg $end
$var reg 1 & Reg2Loc $end
$var reg 1 2 RegWrite $end
$upscope $end
$scope module memtoreg_mux $end
$var wire 64 M ALU_result [63:0] $end
$var wire 1 , src $end
$var wire 64 N data [63:0] $end
$var reg 64 O out [63:0] $end
$upscope $end
$scope module ram $end
$var wire 64 P address [63:0] $end
$var wire 1 ' read_en $end
$var wire 1 # write_en $end
$var wire 64 Q data_in [63:0] $end
$var reg 64 R out [63:0] $end
$var integer 32 S initCount [31:0] $end
$upscope $end
$scope module reg2loc_mux $end
$var wire 5 T a [4:0] $end
$var wire 5 U b [4:0] $end
$var wire 1 & in_cable $end
$var reg 5 V out [4:0] $end
$upscope $end
$scope module regs $end
$var wire 5 W add1 [4:0] $end
$var wire 5 X add2 [4:0] $end
$var wire 1 ! clock $end
$var wire 5 Y write_add [4:0] $end
$var wire 64 Z write_data [63:0] $end
$var wire 1 2 write_en $end
$var reg 64 [ read_1 [63:0] $end
$var reg 64 \ read_2 [63:0] $end
$var integer 32 ] i [31:0] $end
$var integer 32 ^ u [31:0] $end
$upscope $end
$scope module sign_extender $end
$var wire 32 _ in [31:0] $end
$var reg 64 ` out [63:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b111110000 `
b10001011000111110000000000100101 _
b100000 ^
b11111 ]
bx \
bx [
bx Z
b101 Y
b11111 X
b1 W
b11111 V
b101 U
b11111 T
b100000 S
bx R
bx Q
bx P
bx O
bx N
bx M
b10 L
b10001011000 K
bx J
b111110000 I
bx H
b10 G
b10 F
b10001011000 E
b10001011000111110000000000100101 D
b1 C
b1 B
b111110001 A
0@
b111110001 ?
b1 >
b111110000 =
b10 <
bx ;
bx :
b10 9
bx 8
b10 7
06
bx 5
b10 4
03
12
01
b1 0
b10001011000111110000000000100101 /
b111110001 .
bx -
0,
bx +
b11111 *
bx )
bx (
0'
0&
b111110000 %
bx $
0#
0"
0!
$end
#1
b1 $
b1 O
b1 Z
b1 5
b1 ;
b1 M
b1 P
b0 +
b0 8
b0 J
b0 (
b0 H
b0 Q
b0 \
b1 )
b1 :
b1 [
1!
#2
b1 *
b1 V
b1 X
b10000 %
b10000 =
b10000 I
b10000 `
b10010 .
b10010 ?
b10010 A
b1 Y
b1 U
b1 T
b10001011000000010000000000100001 /
b10001011000000010000000000100001 D
b10001011000000010000000000100001 _
b10 0
b10 >
b10 B
b10 C
b100000 ^
0!
#3
b10 $
b10 O
b10 Z
b10 5
b10 ;
b10 M
b10 P
b1 +
b1 8
b1 J
b1 (
b1 H
b1 Q
b1 \
1!
#4
b10011 .
b10011 ?
b10011 A
b11 0
b11 >
b11 B
b11 C
b100000 ^
0!
#5
b100 $
b100 O
b100 Z
b10 +
b10 8
b10 J
b100 5
b100 ;
b100 M
b100 P
b10 (
b10 H
b10 Q
b10 \
b10 )
b10 :
b10 [
1!
#6
b10100 .
b10100 ?
b10100 A
b100 0
b100 >
b100 B
b100 C
b100000 ^
0!
#7
b1000 $
b1000 O
b1000 Z
b100 +
b100 8
b100 J
b1000 5
b1000 ;
b1000 M
b1000 P
b100 (
b100 H
b100 Q
b100 \
b100 )
b100 :
b100 [
1!
#8
b10101 .
b10101 ?
b10101 A
b101 0
b101 >
b101 B
b101 C
b100000 ^
0!
#9
b10000 $
b10000 O
b10000 Z
b1000 +
b1000 8
b1000 J
b10000 5
b10000 ;
b10000 M
b10000 P
b1000 (
b1000 H
b1000 Q
b1000 \
b1000 )
b1000 :
b1000 [
1!
#10
b10110 .
b10110 ?
b10110 A
b110 0
b110 >
b110 B
b110 C
b100000 ^
0!
#11
b100000 $
b100000 O
b100000 Z
b10000 +
b10000 8
b10000 J
b100000 5
b100000 ;
b100000 M
b100000 P
b10000 (
b10000 H
b10000 Q
b10000 \
b10000 )
b10000 :
b10000 [
1!
#12
b11111 *
b11111 V
b11111 X
b111110111 .
b111110111 ?
b111110111 A
b111110000 %
b111110000 =
b111110000 I
b111110000 `
b10 Y
b10 U
b11111 T
b111 0
b111 >
b111 B
b111 C
b10001011000111110000000000100010 /
b10001011000111110000000000100010 D
b10001011000111110000000000100010 _
b100000 ^
0!
#13
b100000 $
b100000 O
b100000 Z
b0 +
b0 8
b0 J
b100000 5
b100000 ;
b100000 M
b100000 P
b0 (
b0 H
b0 Q
b0 \
b100000 )
b100000 :
b100000 [
1!
#14
b111111000 .
b111111000 ?
b111111000 A
b1000 0
b1000 >
b1000 B
b1000 C
b100000 ^
0!
#15
1!
#16
b110 7
b110 9
b110 G
b101 *
b101 V
b101 X
b1011001 .
b1011001 ?
b1011001 A
b1010000 %
b1010000 =
b1010000 I
b1010000 `
b11001011000 K
b11001011000 E
b10000 Y
b10000 U
b101 T
b1001 0
b1001 >
b1001 B
b1001 C
b11001011000001010000000000110000 /
b11001011000001010000000000110000 D
b11001011000001010000000000110000 _
b100000 ^
0!
#17
b11111 $
b11111 O
b11111 Z
b11111 5
b11111 ;
b11111 M
b11111 P
b1 +
b1 8
b1 J
b1 (
b1 H
b1 Q
b1 \
1!
#18
bx 5
bx ;
bx M
bx P
bx -
bx N
bx R
bx $
bx O
bx Z
b0xxxxxxxxx +
b0xxxxxxxxx 8
b0xxxxxxxxx J
b10 7
b10 9
b10 G
b0 4
b0 F
b0 L
1'
1,
16
bx *
bx V
bx X
b0xxxxxxxxx %
b0xxxxxxxxx =
b0xxxxxxxxx I
b0xxxxxxxxx `
bx .
bx ?
bx A
bx K
bx E
bx Y
bx W
bx U
bx T
bx /
bx D
bx _
b1010 0
b1010 >
b1010 B
b1010 C
b100000 ^
0!
#19
bx (
bx H
bx Q
bx \
bx )
bx :
bx [
1!
#20
b1011 0
b1011 >
b1011 B
b1011 C
0!
