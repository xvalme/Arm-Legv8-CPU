$date
	Sun Mar 06 16:04:17 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module CPU_tb $end
$scope module cpu $end
$var wire 1 ! clock $end
$var wire 1 " en_jump $end
$var wire 1 # writemem_en_id_ex $end
$var wire 1 $ writemem_en_ex_mem $end
$var wire 1 % writemem_en $end
$var wire 5 & write_reg_mem_wb [4:0] $end
$var wire 5 ' write_reg_id_ex [4:0] $end
$var wire 5 ( write_reg_ex_mem [4:0] $end
$var wire 64 ) write_data [63:0] $end
$var wire 64 * sign_extended_address_id_ex [63:0] $end
$var wire 64 + sign_extended_address [63:0] $end
$var wire 1 , reg2loc $end
$var wire 1 - readmem_en_id_ex $end
$var wire 1 . readmem_en_ex_mem $end
$var wire 1 / readmem_en $end
$var wire 64 0 read2_id_ex [63:0] $end
$var wire 64 1 read2_ex_mem [63:0] $end
$var wire 64 2 read2 [63:0] $end
$var wire 64 3 read1_id_ex [63:0] $end
$var wire 64 4 read1 [63:0] $end
$var wire 5 5 out_reg2loc [4:0] $end
$var wire 64 6 out_ALUSrc [63:0] $end
$var wire 1 7 memtoreg_mem_wb $end
$var wire 1 8 memtoreg_id_ex $end
$var wire 1 9 memtoreg_ex_mem $end
$var wire 1 : memtoreg $end
$var wire 64 ; mem_data_mem_wb [63:0] $end
$var wire 64 < mem_data [63:0] $end
$var wire 64 = jump_address_ex_mem [63:0] $end
$var wire 64 > jump_address [63:0] $end
$var wire 32 ? instruction [31:0] $end
$var wire 64 @ counter [63:0] $end
$var wire 11 A alu_ctrl_data [10:0] $end
$var wire 1 B Zero_ex_mem $end
$var wire 1 C Zero $end
$var wire 1 D UncBranch_id_ex $end
$var wire 1 E UncBranch_ex_mem $end
$var wire 1 F UncBranch $end
$var wire 1 G RegWrite_mem_wb $end
$var wire 1 H RegWrite_id_ex $end
$var wire 1 I RegWrite_ex_mem $end
$var wire 1 J RegWrite $end
$var wire 32 K Instruction_if_id [31:0] $end
$var wire 64 L Counter_if_id [63:0] $end
$var wire 64 M Counter_id_ex [63:0] $end
$var wire 1 N Branch_id_ex $end
$var wire 1 O Branch_ex_mem $end
$var wire 1 P Branch $end
$var wire 2 Q AluOp [1:0] $end
$var wire 2 R AluOP_id_ex [1:0] $end
$var wire 64 S ALU_out_mem_wb [63:0] $end
$var wire 64 T ALU_out_ex_mem [63:0] $end
$var wire 64 U ALU_out [63:0] $end
$var wire 1 V ALUSrc_id_ex $end
$var wire 1 W ALUSrc $end
$var wire 4 X ALUCtrl [3:0] $end
$scope module ALU $end
$var wire 64 Y B [63:0] $end
$var wire 4 Z ALUctr [3:0] $end
$var wire 64 [ A [63:0] $end
$var reg 64 \ Out [63:0] $end
$var reg 1 C Zero $end
$upscope $end
$scope module Aluctrl $end
$var wire 2 ] ALU_Op [1:0] $end
$var wire 11 ^ ALU_INSTRUCTION [10:0] $end
$var reg 4 _ ALU_Out [3:0] $end
$upscope $end
$scope module EX_MEM $end
$var wire 64 ` alu_result [63:0] $end
$var wire 1 ! clock $end
$var wire 1 C zero $end
$var wire 5 a write_reg [4:0] $end
$var wire 1 D uncBranch $end
$var wire 1 H regWrite $end
$var wire 64 b read2 [63:0] $end
$var wire 1 # memwrite $end
$var wire 1 8 memtoReg $end
$var wire 1 - memread $end
$var wire 1 N branch $end
$var wire 64 c add_result [63:0] $end
$var reg 64 d Add_result [63:0] $end
$var reg 64 e Alu_result [63:0] $end
$var reg 1 O Branch $end
$var reg 1 . Memread $end
$var reg 1 9 MemtoReg $end
$var reg 1 $ Memwrite $end
$var reg 64 f Read2 [63:0] $end
$var reg 1 I RegWrite $end
$var reg 1 E UncBranch $end
$var reg 5 g Write_reg [4:0] $end
$var reg 1 B Zero $end
$upscope $end
$scope module ID_EX $end
$var wire 1 ! clock $end
$var wire 1 F uncond_branch $end
$var wire 64 h sign_extended [63:0] $end
$var wire 1 J regWrite $end
$var wire 64 i read2 [63:0] $end
$var wire 64 j read1 [63:0] $end
$var wire 64 k pc [63:0] $end
$var wire 1 % memwrite $end
$var wire 1 : memtoReg $end
$var wire 1 / memread $end
$var wire 32 l instruction [31:0] $end
$var wire 1 P branch $end
$var wire 2 m aluop [1:0] $end
$var wire 1 W aluSrc $end
$var reg 1 V ALUSrc $end
$var reg 2 n Aluop [1:0] $end
$var reg 1 N Branch $end
$var reg 1 - Memread $end
$var reg 1 8 MemtoReg $end
$var reg 1 # Memwrite $end
$var reg 64 o Pc [63:0] $end
$var reg 64 p Read1 [63:0] $end
$var reg 64 q Read2 [63:0] $end
$var reg 1 H RegWrite $end
$var reg 64 r Sign_extended [63:0] $end
$var reg 1 D Uncond_Branch $end
$var reg 11 s alu_ctrl_data [10:0] $end
$var reg 5 t write_reg [4:0] $end
$upscope $end
$scope module IF_ID $end
$var wire 1 ! clock $end
$var wire 64 u pc [63:0] $end
$var wire 32 v instruction [31:0] $end
$var reg 32 w Instruction [31:0] $end
$var reg 64 x Pc [63:0] $end
$upscope $end
$scope module JumpAdder $end
$var wire 64 y A [63:0] $end
$var wire 4 z ALUctr [3:0] $end
$var wire 64 { B [63:0] $end
$var reg 64 | Out [63:0] $end
$var reg 1 } Zero $end
$upscope $end
$scope module MEM_WB $end
$var wire 64 ~ alu_result [63:0] $end
$var wire 1 ! clock $end
$var wire 1 9 memtoReg $end
$var wire 1 I regWrite $end
$var wire 5 !" write_reg [4:0] $end
$var wire 64 "" read_data [63:0] $end
$var reg 64 #" Alu_result [63:0] $end
$var reg 1 7 MemtoReg $end
$var reg 64 $" Read_data [63:0] $end
$var reg 1 G RegWrite $end
$var reg 5 %" Write_reg [4:0] $end
$upscope $end
$scope module PC $end
$var wire 1 ! clock $end
$var wire 1 " en_jump $end
$var wire 64 &" jump [63:0] $end
$var reg 64 '" counter [63:0] $end
$upscope $end
$scope module ROM $end
$var wire 1 ! clock $end
$var wire 64 (" counter [63:0] $end
$var reg 32 )" instruction [31:0] $end
$upscope $end
$scope module alusrc_mux $end
$var wire 64 *" address [63:0] $end
$var wire 1 V alusrc $end
$var wire 64 +" reg2 [63:0] $end
$var reg 64 ," out [63:0] $end
$upscope $end
$scope module control_unit $end
$var wire 11 -" Instruction [10:0] $end
$var reg 1 W ALUSrc $end
$var reg 2 ." AluOp [1:0] $end
$var reg 1 P Branch $end
$var reg 1 / MemRead $end
$var reg 1 % MemWrite $end
$var reg 1 : MemtoReg $end
$var reg 1 , Reg2Loc $end
$var reg 1 J RegWrite $end
$var reg 1 F UncBranch $end
$upscope $end
$scope module memtoreg_mux $end
$var wire 64 /" ALU_result [63:0] $end
$var wire 64 0" data [63:0] $end
$var wire 1 7 src $end
$var reg 64 1" out [63:0] $end
$upscope $end
$scope module ram $end
$var wire 64 2" address [63:0] $end
$var wire 64 3" data_in [63:0] $end
$var wire 1 . read_en $end
$var wire 1 $ write_en $end
$var reg 64 4" out [63:0] $end
$var integer 32 5" initCount [31:0] $end
$upscope $end
$scope module reg2loc_mux $end
$var wire 5 6" a [4:0] $end
$var wire 5 7" b [4:0] $end
$var wire 1 8" in_cable $end
$var reg 5 9" out [4:0] $end
$upscope $end
$scope module regs $end
$var wire 5 :" add1 [4:0] $end
$var wire 5 ;" add2 [4:0] $end
$var wire 1 ! clock $end
$var wire 5 <" write_add [4:0] $end
$var wire 64 =" write_data [63:0] $end
$var wire 1 G write_en $end
$var reg 64 >" read_1 [63:0] $end
$var reg 64 ?" read_2 [63:0] $end
$var integer 32 @" i [31:0] $end
$var integer 32 A" u [31:0] $end
$upscope $end
$scope module sign_extender $end
$var wire 32 B" in [31:0] $end
$var reg 64 C" out [63:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx C"
bx B"
bx A"
b11111 @"
bx ?"
bx >"
bx ="
bx <"
bx ;"
bx :"
bx 9"
x8"
bx 7"
bx 6"
b100000 5"
bx 4"
bx 3"
bx 2"
bx 1"
bx 0"
bx /"
bx ."
bx -"
bx ,"
bx +"
bx *"
b10001011000000100000000001100001 )"
b0 ("
b0 '"
bx &"
bx %"
bx $"
bx #"
bx ""
bx !"
bx ~
0}
bx |
bx {
b10 z
bx y
bx x
bx w
b10001011000000100000000001100001 v
b0 u
bx t
bx s
bx r
bx q
bx p
bx o
bx n
bx m
bx l
bx k
bx j
bx i
bx h
bx g
bx f
bx e
bx d
bx c
bx b
bx a
bx `
bx _
bx ^
bx ]
bx \
bx [
bx Z
bx Y
bx X
xW
xV
bx U
bx T
bx S
bx R
bx Q
xP
xO
xN
bx M
bx L
bx K
xJ
xI
xH
xG
xF
xE
xD
xC
xB
bx A
b0 @
b10001011000000100000000001100001 ?
bx >
bx =
bx <
bx ;
x:
x9
x8
x7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
x/
x.
x-
x,
bx +
bx *
bx )
bx (
bx '
bx &
x%
x$
x#
x"
0!
$end
#1
0F
b10 Q
b10 m
b10 ."
0P
0%
0/
1J
0:
0W
0,
b10 5
b10 9"
b10 ;"
b100000 +
b100000 h
b100000 C"
b10001011000 -"
b11 :"
08"
b1 7"
b10 6"
b10001011000000100000000001100001 K
b10001011000000100000000001100001 l
b10001011000000100000000001100001 w
b10001011000000100000000001100001 B"
b0 L
b0 k
b0 x
b100000 A"
1!
#2
b10 2
b10 i
b10 ?"
b11 4
b11 j
b11 >"
0!
#3
b100000 >
b100000 c
b100000 |
b10 6
b10 Y
b10 ,"
0C
b101 U
b101 \
b101 `
b10 X
b10 Z
b10 _
0"
07
1G
b1 &
b1 %"
b1 <"
0E
09
1I
0$
0.
0O
b1 (
b1 g
b1 !"
b10 1
b10 f
b10 3"
0D
08
1H
0#
0-
0N
0V
b10 R
b10 ]
b10 n
b0 M
b0 o
b0 y
b100000 *
b100000 r
b100000 {
b100000 *"
b10 0
b10 b
b10 q
b10 +"
b11 3
b11 [
b11 p
b1 '
b1 a
b1 t
b10001011000 A
b10001011000 ^
b10001011000 s
b100000 A"
1!
#4
b1 @
b1 u
b1 '"
b1 ("
0!
#5
b1 L
b1 k
b1 x
b100000 A"
0B
b101 T
b101 e
b101 ~
b101 2"
b100000 =
b100000 d
b100000 &"
1!
#6
bx ?
bx v
bx )"
b10 @
b10 u
b10 '"
b10 ("
0!
#7
b0 Q
b0 m
b0 ."
1/
1:
1W
bx 5
bx 9"
bx ;"
b101 )
b101 1"
b101 ="
b100010 >
b100010 c
b100010 |
b0xxxxxxxxx +
b0xxxxxxxxx h
b0xxxxxxxxx C"
bx -"
bx :"
x8"
bx 7"
bx 6"
bx &
bx %"
bx <"
b101 S
b101 #"
b101 /"
bx (
bx g
bx !"
b10 M
b10 o
b10 y
bx '
bx a
bx t
bx A
bx ^
bx s
b100000 A"
bx K
bx l
bx w
bx B"
b10 L
b10 k
b10 x
1!
#8
b11 @
b11 u
b11 '"
b11 ("
bx 2
bx i
bx ?"
bx 4
bx j
bx >"
0!
#9
bx >
bx c
bx |
b0xxxxxxxxx 6
b0xxxxxxxxx Y
b0xxxxxxxxx ,"
bx U
bx \
bx `
b11 L
b11 k
b11 x
b100000 A"
18
1-
1V
b0 R
b0 ]
b0 n
b0xxxxxxxxx *
b0xxxxxxxxx r
b0xxxxxxxxx {
b0xxxxxxxxx *"
bx 0
bx b
bx q
bx +"
bx 3
bx [
bx p
b100010 =
b100010 d
b100010 &"
1!
#10
b100 @
b100 u
b100 '"
b100 ("
0!
#11
bx )
bx 1"
bx ="
17
bx S
bx #"
bx /"
19
1.
bx 1
bx f
bx 3"
bx T
bx e
bx ~
bx 2"
bx =
bx d
bx &"
b100 M
b100 o
b100 y
b100000 A"
b100 L
b100 k
b100 x
1!
#12
b101 @
b101 u
b101 '"
b101 ("
0!
#13
b101 L
b101 k
b101 x
b100000 A"
1!
#14
b110 @
b110 u
b110 '"
b110 ("
0!
#15
b110 M
b110 o
b110 y
b100000 A"
b110 L
b110 k
b110 x
1!
#16
b111 @
b111 u
b111 '"
b111 ("
0!
#17
b111 L
b111 k
b111 x
b100000 A"
1!
#18
b1000 @
b1000 u
b1000 '"
b1000 ("
0!
#19
b1000 M
b1000 o
b1000 y
b100000 A"
b1000 L
b1000 k
b1000 x
1!
#20
b1001 @
b1001 u
b1001 '"
b1001 ("
0!
#21
b1001 L
b1001 k
b1001 x
b100000 A"
1!
#22
b1010 @
b1010 u
b1010 '"
b1010 ("
0!
#23
b1010 M
b1010 o
b1010 y
b100000 A"
b1010 L
b1010 k
b1010 x
1!
#24
b1011 @
b1011 u
b1011 '"
b1011 ("
0!
#25
b1011 L
b1011 k
b1011 x
b100000 A"
1!
#26
b1100 @
b1100 u
b1100 '"
b1100 ("
0!
#27
b1100 M
b1100 o
b1100 y
b100000 A"
b1100 L
b1100 k
b1100 x
1!
#28
b1101 @
b1101 u
b1101 '"
b1101 ("
0!
#29
b1101 L
b1101 k
b1101 x
b100000 A"
1!
#30
b1110 @
b1110 u
b1110 '"
b1110 ("
0!
#31
b1110 M
b1110 o
b1110 y
b100000 A"
b1110 L
b1110 k
b1110 x
1!
#32
b1111 @
b1111 u
b1111 '"
b1111 ("
0!
#33
b1111 L
b1111 k
b1111 x
b100000 A"
1!
#34
b10000 @
b10000 u
b10000 '"
b10000 ("
0!
#35
b10000 M
b10000 o
b10000 y
b100000 A"
b10000 L
b10000 k
b10000 x
1!
#36
b10001 @
b10001 u
b10001 '"
b10001 ("
0!
#37
b10001 L
b10001 k
b10001 x
b100000 A"
1!
#38
b10010 @
b10010 u
b10010 '"
b10010 ("
0!
#39
b10010 M
b10010 o
b10010 y
b100000 A"
b10010 L
b10010 k
b10010 x
1!
#40
b10011 @
b10011 u
b10011 '"
b10011 ("
0!
#41
b10011 L
b10011 k
b10011 x
b100000 A"
1!
#42
b10100 @
b10100 u
b10100 '"
b10100 ("
0!
#43
b10100 M
b10100 o
b10100 y
b100000 A"
b10100 L
b10100 k
b10100 x
1!
#44
b10101 @
b10101 u
b10101 '"
b10101 ("
0!
#45
b10101 L
b10101 k
b10101 x
b100000 A"
1!
#46
b10110 @
b10110 u
b10110 '"
b10110 ("
0!
#47
b10110 M
b10110 o
b10110 y
b100000 A"
b10110 L
b10110 k
b10110 x
1!
#48
b10111 @
b10111 u
b10111 '"
b10111 ("
0!
#49
b10111 L
b10111 k
b10111 x
b100000 A"
1!
#50
b11000 @
b11000 u
b11000 '"
b11000 ("
0!
